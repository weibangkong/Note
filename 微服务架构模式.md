# 微服务架构模式

## 1.微服务基础

#### 	1.定义	

​		把应用程序功能性的分解为一组服务，每一组服务都是由一组专注的、内聚、内聚的功能职责组成（服务没有体量大小的规定）

#### 	2.采用微服务架构的好处

​		1.为持续交付和持续部署提供了可能性

​		2.每个服务都较小并且容易维护

​		3.服务可以独立部署

​		4.服务可以独立扩展

​		5.可以实现团队自治

​		6.功能日实验和采纳新的技术

​		7.更好的容错性

​		ps:因为服务可以独立部署和扩展，所以可以满足高可用和高扩展性

#### 	3.与微服务互为替代模式的单体模式的好处

​		1.开发简单

​		2.易于对应用程序进行大规模的改动

​		3.测试简单直观

​		4.部署简单

​		5.横向扩展简单

#### 	4.采用微服务架构模式带来的问题及基本解决方案

​		1.只能适应而不能规避的全局事务一致性事务和数据一致性问题(因为每个服务都都自己独有的数据库，可通过saga解决)

​		2.跨多个服务查询问题(使用API组合或者CQRS视图查询)

​		3.服务间的通信问题(或者说是进程间的服务通信)

​		4.服务拆分是一个问题（服务边界的定义）

​		5.跨多个服务的功能的部署问题(运维的复杂性)

#### 	5.微服务架构模式的使用场景

#### 	6.微服务架构模式与模块化开发

#### 	7.杂项



## 2.服务拆分

将操作分配给需要操作所提供信息的服务，其他情况下将操作分配给具有处理他所需信息的服务

#### 软件架构定义

是构建一个系统所需的一组结构，包括软件元素和元素间的关系，以及这二者的属性

#### 软甲架构的4+1模型

逻辑视图：有开发人员创建，元素为类和包，关系为类和包之间的关系，如继承、关联、依赖等

实现试图：构建编译系统的输出(打包代买的模块和组建组成，组件是一个或者多个模块组成的可执行单元或可部署单元)，元素为模块(JAR文件)和组件(WAR文件或可执行文件)，关系为这些模块或组件的依赖关系或者组合关系

进程试图：运行的组件，元素为进程，关系为进程间通信

部署视图：描述进程如何映射到机器，运行在机器上的进程，元素由机器或者虚拟机和进程，关系为各机器之间的网络

#### 关于架构：

应用程序的需求，可以分为两个层面

1.功能性需求--该部分可以通过任意的架构来实现

2.非功能性需求--该部分即是架构的重要性所在，非功能性需求也称之为质量属性需求(也可以简称为“能力”)，非功能性需求决定了一个应用程序在运行时的质量，比如可扩展性和可靠性，也决定了开发阶段的质量(包括可维护性、可测试性，可扩展性和可部署性)

软件架构主要形象的是非功能性需求



#### 架构风格：

分层式架构风格：将软件元素按“层”的方式管理

##### 弊端：

只有单个表现层；无法展现应用层序可能不仅仅由单个系统调用的事实

单一的数据持久化层：无法展现应用程序可能与多个数据库进行交互的事实

业务逻辑层定义为依赖于数据持久化层：会影响在没有数据库的情况下测试业务逻辑

六边形架构风格(核心元素概念出)：以架构风格选择以业务逻辑为中心的方式组织逻辑视图，应用程序拥有一个或多个入站适配器(如Spring MVC中的Controller，再比如订阅消息的消息代理客户端)，通过由适配器调用业务逻辑来处理来自外部的请求，相同的，应用程序也应有多个出战适配器，这些出站适配器被业务逻辑调用来调用并调用外部应用程序(如实现访问数据库操作的数据访问对象DAO类，或者调用远程服务的代理类，或者消息机制中的事件发布者)，架构的关键特性是业务逻辑不依赖适配器，相反的适配器依赖业务逻辑

##### 优点：

将业务逻辑与适配器中包含的表示层和数据访问层的逻辑分离开。业务逻辑不依赖于表示层逻辑或数据访问层逻辑

上帝类的消除

准确的反映了现代应用程序的架构，可以通过多个适配器调用业务逻辑，每个适配器实现特定的API或者用户界面，业务罗杰也可以调用过多个适配器，每个适配器调用不同的外部系统，六边形架构是描述微服务架构中每个服务的架构的好方法。

#### 微服务架构：

将应用程序构建为受能够和、可独立部署的一组服务

#### 单体架构：

将应用程序构建为单个可执行和可部署组件



#### 什么是服务：

服务是一个单一的、可独立部署的软件组建，对外仅暴露服务API(无法绕过服务的API直接访问服务内部的方法和数据)，API由命令、查询和事件组成，同时可以发布事件给其客户端使用

##### 为应用程序定义微服务架构：

1.将应用程序的需求提炼为各种关键请求，但是不是根据特定的进程件通信技术来描述这些请求，而是使用更加抽象的系统操作这个概念

系统操作：是应用程序必须处理的请求的一种抽象描述，既可以是更新数据的命令，也可以是检索数据的查询，每个命令的行为都是根据抽象领域模型定义的，而抽象领域模型也是从需求中派生出来的，系统操作是描述服务之间协作方式的架构场景。

2.确定如何分解服务：有几种策略可供选择，一种源于业务架构学派的策略是定义与业务能力相对应的服务。另一种策略是围绕领域驱动设计的子域来分解和设计服务，但是最终结果都是围绕业务概念而非技术概念分解和设计服务

3.确定每个服务的API和服务间的协作方式：将第一步确定的系统操作分配个第二步确定的服务，服务可以完全独立的实现操作或者可以能需要与其他服务协作，这种情况下，需要确定服务的协作方式，还需要确定选用哪种进程间通信机制来实现每个服务的API。

##### 服务分解是需要客服的几个障碍：

1.网络延迟：可能由于服务间的网络往返太多

2.因服务间的同步通信而导致可用性的降低

3.需要维护跨服务的数据一致性，需要使用Saga

4.上帝类，可以通过领域驱动设计中的概念来消除上帝类

##### 事务驱动模式：

当前开发模式(贫血模型--数据对象不具有状态和行为)

##### 领域驱动模式：

step1：创建由系统关键类组成的抽象领域模型(失血模型以及可以对象化的行为(如点餐系统中的”配送“))，这些关键类用于描述系统操作的词汇表

step2：确定系统操作，并根据领域模型描述每个系统操作的行为

##### 根据业务能力对服务进行拆分：



## 3.进程通信

#### 1.选择进程通信的方式的两个维度

1.一对多还是一对一

2.同步还是异步



#### 2.消息格式：

文本格式(Json、xml)弊端消息往往过度冗长尤其是xml

二进制格式常用的室Protocol Buffers 和Avro，这两种格式都提供了一个强类型定义的IDL(interface descripttion language)



#### 3.基于同步远程过程调用模式的通信

1.RESTful(使用Http动词来制定对某一资源所采取的操作)

REST成熟度模型(分为4个层次)

Level 0：每个请求都指明了需要执行的操作、操作针对的目标(如业务对象和必要的参数)

Level 1：请求中指定要执行的操作和包含任何参数的POST请求

Level 2：使用Http动词表示对目标资源所采取的动作，需要传递资源参数

Level 3：基于HATEOAS原则设计，基本思想是由GET请求返回的资源信息中包含该资源所允许的操作的连接，优点是无需再客户端代码中写入硬链接的URL，同时因为资源信息中包含了可允许操作的连接，客户无需猜测在资源的当前状态下执行何种操作



#### 4.REST好处和弊端

好处：

1.简单，大家熟悉

2.可以使用浏览器扩展（例如Postman插件）或者curl之类的命令行来测试HTTP API

3.直接支持请求/相应方式的通信

4.HTTP对防火墙友好

5.不需要做中间代理

弊端：

只支持请求/相应方式的通信

可能导致可用性降低啊，因为客户端和服务端之间直接通信没有代理来缓冲消息，因此必须在调用期间都保持在线

客户端必须知道服务实例的位置(URL)，客户端必须使用所谓的服务发现机制来定位服务实例

在单个请求中获取多个资源具有挑战性(如微服务架构下，需要订单和客户信息)

在更新操作很多的情况下，很难将他们都映射到HTTP动词



#### 5.gRPC:

gRPC是一种基于二进制消息的协议

##### 好处：

设计具有复杂更新操作的API非常简单

他具有高效、紧凑的进程间通信机制，尤其是交换大量消息时

支持在远程过程调用和消息传递过程中使用双向流式消息方式

实现了客户端和用各种语言编写的服务端之间的互操作性

##### 弊端：

与基于REST/JSON的API机制相比，javaScript客户端使用基于gRPC的API需要做更多的工作

旧时防火墙可能不支持HTTP/2

与REST一样，是一种同步通信机制，因此他也存在局部故障的问题，可以使用断路器模式处理局部故障

##### 断路器模式：

这是一个远程过程调用的代理，在连续失败次数超过指定阈值后的一段时间内这个代理就会立即拒绝其他调用

##### 需要处理的问题：

1.必须让远程过程调用代理有正确处理无响应服务的能力

2.需要决定如何从失败的远程服务中恢复



对局部故障的处理

当一个服务同步调用另一个服务是，应该要添加的处理：

1.添加网络超时:一定不要做成无限阻塞，而是要设定一个超时，使用超时可以保证不会一直在无响应的请求上浪费时间

2.限制客户端想服务器发出请求的数量:把客户端能够像特定服务发起的请求设置一个上线，如果请求达到了这样的上线，很有可能发起更多的请求也无济于事，此时就应该让球球立刻失败

3.断路器模式，监控客户端发出请求的成功和失败数量，如果失败的比例超过一定阈值就启动断路器，让后续调用立刻失效；但是经过一段时间后，客户端应该继续尝试请求，如果调用成功，则接触断路器

从服务失效故障中恢复解决方案：

1.服务只是向其客户端返回错误

2.返回备用之(例如默认值或者缓存响应)



服务发现：

使用服务发现的原因：服务实例具有动态分配的网络位置，还可能由于自动扩展、故障和升级、服务实例集会动态更改，因此客户端代码必须使用服务发现

什么是服务发现

服务发现主要的两种方式

1.服务及其客户直接与服务注册表交互:应用程序的服务及其客户端与服务注册表进行交互，服务实例使用服务注册表注册自己的网络位置，客户端首先通过查询服务注册表获取服务实例列表来调用服务，让后香气中一个实例发送请求(服务注册表跟踪记录服务实例，客户端查询服务注册表)

这种方式也是两个模式的组合：

第一种模式是自注册模式(服务实例想服务注册表注册自己即有对外暴露服务的服务主动发起)，自注册模式和可以提供运行状况检测URL，服务注册表会定期调用该断电来验证服务实例是否正常且可用于处理请求，服务注册表还可能要求服务实例定期调用“心跳“API”以防止其注册过期

第二种模式是客户端发现模式(客户端从服务注册表检索可用服务实例的列表，并在他们之间进行负载均衡)。当客户端想要调用服务是，他会查询服务注册表以获取服务实例的地址。为了提高性能，客户端可能会缓存服务实例。然后客户端使用负载均衡算法来选择服务实例。然后他想选择的服务实例发送请求。

应用层服务发现的一个弊端是：你需要为你是用的每种变成语言提供服务发现库，存在跨语言问题，至于为什么优先使用Eureka而不是Kubernetes是因为基于Kubernetes的服务发现仅能用于部署在Kubernetes平台之上的部分服务，二Eureka可以同时适用于老环境和Kubernetes上的服务

2.通过部署基础设施来处理服务发现(平台层服务发现模式)

通过部署平台来实现服务注册表和服务发现机制，如Docker和Kubernetes，部署平台为每个服务提供DNS名称、虚拟IP(VIP)地址和解析为VIP地址的DNS名称。客户端向DNS名称和VIP发出请求，部署平台自动将请求路由到其中一个可用服务实例。因此服务注册、服务发现和请求路由完全由部署平台处理

部署平台包含一个服务注册，用于跟踪已部署服务的IP地址。

该中方法是一下两种模式的组合：

第三方注册模式：由第三方负责处理注册。而不是服务本身想服务注册表注册自己

服务端发现模式：客户端不再需要服务注册表，而是想DNS名称发出请求，对该DNS名称的请求被解析到路由器，路由器查询服务注册表并对请求进行负载均衡



第三方注册模式：服务实例由第三方自动注册到服务注册表

服务端发现模式：客户端像路由器发出请求，路由器负责服务发现

平台提供该服务发现机制的好处是：服务发现的所有方面都完全由部署平台处理，服务端和客户端都不包含任何服务发现的代码。

弊端是：他仅支持使用该平台部署的服务



异步消息机制

使用消息机制时，服务之间的通信采用异步交换数据的方式完成，一把使用消息代理，从当服务之间的中介，如使用ActiviMQ、RabbitMQ、Kafaka。

消息：

消息由消息头和消息体组成：

标题是名称和值对的集合，描述正在发送的数据和元素据，消息头中海应包含其他信息，如发件人或消息传递基础设施生成的唯一消息ID，以及可选的返回地址，该地址制定发送恢复的消息通道，消息正文是以文本或二进制格式发送数据

存在几种不同类型的消息：

文档：仅包含数据的通用消息，接收者决定如何解释他。对命令式消息的恢复是文档消息的一种使用场景

命令：一条等同于RPC请求的消息。他制定要调用的操作及其阐述

事件：表示发送方这一端发生了重要的事件。事件通常是领域事件，表示领域对象的状态更改

消息通道：消息通过消息通道进行交换

存在以下两种类型：

点对点通道:想正在从通道读取的一个消费者出传递消息，服务可以通过点对点通道来实现前面描述的一对一交互方式，如命令式消息通常是用点对点通道发布

发布-订阅通道：将一条消息发给所有订阅的接收方。服务使用发布-订阅通道来实现前面的一对多交互，如事件式消息通常发布-订阅通道发送

使用消息通道实现请求/相应和异步请求/相应：

客户端和服务端通过交换一对消息来实现异步请求/相应方式的交互，客户端必须告知服发送恢复消息的位置，并且必须将恢复消息和请求匹配(客户端发送具有回复通道头部的命令式消息，服务器将回复消息写入回复通道，该回复消息包含与消息标识符具有相同值的相关性ID。客户端使用相关性ID将回复消息与请求进行匹配，发送消息的通道和回复的通道不是同一个)

实现单项通知：客户端将消息发送到服务所拥有的点对点通道。服务订阅该通道并处理该消息，但是服务不会发回回复

实现发布/订阅

实现发布/异步相应

将发布/订阅和请求/响应结合，客户端发布一条消息，在小溪的头部中制定回复通道，这个通道同hi也是一个发布-订阅通道，消费者将包含相关性id的回复消息写入回复通道，客户端通过使用相关性ID来收集相应

为基于消息机制的服务API创建API规范:

服务的异步API规范必须制定消息通道的名称、通过每个通道交换的消息类型及其后格式。还必须使用诸如JSON\XML或Protobuf之类的标准来描述消息的格式

请求/异步响应式API：包括服务的命令消息通道、服务接受的命令式消息的具体类型和格式，以及服务发送的回复消息的类型和格式

单向通知式API：包括服务的命令消息通道，以及服务接受的命令式消息的具体类型和格式

服务可以对异步请求/响应和单向通知使用相同的请求通道

消息机制的架构：

1.无代理消息架构，服务可以直接交互消息如使用ZeroMQ

好处：

允许更轻的网络流量和更低的延迟

消除了消息代理成为性能瓶颈和单点故障的可能性

具有较低的操作复杂性，因为不需要设置和维护消息代理

弊端：

服务需要理解彼此的位置，因此必须使用服务发现机制

会降低可用性，因为在交互时，消息的发送方和接受方都必须在线

在实现例如确保消息能供成功投递这些复杂功能的挑战性更大

其中使可用性降低和需要服务发现机制都与同步请求/响应交互方式所导致的弊端相同

基于代理的消息：消息代理时所有消息的中介节点，发送方将消息写入消息代理，消息代理将消息发送给接受者，如ActiveMQ，RabbitMq，Kafka

使用消息代理的好处：

1.发送方不需要知道服务端的网络位置

2.另一个好处时消息代理可以缓冲消息，知道接受方能狗狗处理他们

在选择消息代理时需要考虑的因素：

支持的变成语言

支持的消息标准

是否满足消息的有序性

是否可以保证投递

持久性：是否可以将消息持久化到吃饱并且能够在代理崩溃时回复

耐久性：如果接受方重新连接到消息代理，他是否会受到断开连接时发送的消息

可扩展性：

延迟：端到端是否有较大延迟

消息代理是否支持竞争性接收方

使用消息代理额好处和弊端：

好处：

1.松耦合，客户端只需要将消息发送到特定通道，不需要感知服务端实例的情况，也不需要使用服务发现机制来获取服务实例的网络位置

2.消息缓存：消息代理可以在消息被处理之前一直缓存消息

3.灵活的通信：消息机制支持前面提到的所有的交互方式

4.明确的进程间通信

弊端：

1.潜在的性能瓶颈：消息的代理可能存在性能瓶颈

2.潜在的单点故障

3.额外的操作复杂性:炫耀单独安装，部署，运维



在基于消息的架构中可能会遇到一些问题：

1.处理并发和消息顺序：

常见解决方案时使用分片：

1.分片通道由两个或多个分片组成，每个分片的行为类似于一个通道

2.发送发在消息头部制定分片键，通常时任意字符串或者字节序列，消息代理使用分片键将消息分配给特定的分片

3.消息代理将接收方的多个实例组合在一起，并将他们视为相同的逻辑接收方

处理重复消息：

解决方案：

1.编写幂等消息处理程序，通常情况下较难实现

2.跟中消息并丢弃重复项，一个简单的解决方案时消息接受方使用message_id跟踪他已处理的消息并丢弃任何重复项(如它可以存储他在数据库表中使用的每条嘻嘻的message id)，当接收方处理消息时，他将消息的message作为创建和更新业务实体的一部分记录在数据库表中，如果消息重复(即表中存在该message id)则表示接收方可以丢弃该消息。

另一个选项时消息处理程序在应用程序表，而不是专用表中记录message id。当使用事务受限的NoSQL数据库时，此方法有用，因为NoSQL数据库通常不支持将针对两个表的更新作为数据库的事务



事务性消息：

服务通常需要在更新数据库的事务中发布消息，服务应该以原子方式执行这两个错做，否则可能使系统处于不一致状态。

解决方案：

1.事务性发件箱(使用数据表作为消息队列)，作为创建、更新和删除对象业务的数据库事务的一部分，服务通过将消息插入到outbox表中来发送消息.(原理时借助本地数据库的ACID实现事务性)

2.将消息从数据库移动到消息代理并对外发送有两种不同的方法：

1.轮询outbox表，将为发送的消息发送出去，该模式的比对时经常轮询数据库可能造成昂贵的开销，此外，此项是否适合NoSQL数据库取决于NoSQL数据支持的查询功能，这是因为应用程序必须查询业务尸体，而不是查询outbox表。

2.更好的办法是使用事务日志拖尾模式发布事件



使用异步消息提高可用性：

使用同步消息会降低可用性

消除同步交互

在不许处理同步请求的情况下，仍旧有一些方式可以最大先对的降低同步通信的数量。

解决方案：

1.使用异步交互模式(完全异步消息机制)，但是这种解决方案一般难以达到，服务很多情况下都是用类似REST这样的同步通信协议的外部API,并且要求请求立即做出响应。

2.为解决上面方案的弊端，可以采用复制数据的方式减少同步,要求服务维护一个数据副本，这些数据是服务在处理请求时需要使用的，这些数据的源头会在数据发生变化时发布消息，服务只需要订阅这些消息，来确保数据分本的事实更新。复制数据的弊端在于：如果被复制的数据量巨大，会导致效率低下，另一个弊端在于，复制数据并没有从根本上解决服务如何更新其他服务所拥有的数据这个问题

3.为了解决复制数据的弊端，一种可取方法时让服务展缓与其他服务交互，直到他给客户端发送了响应(可以通过Saga实现)，具体步骤如下：

1.仅使用本地的数据来完成请求的验证

2.更新数据库，包括想outbox表插入数据

3.向客户端返回相应



## 4.Saga管理事务

1.Saga:一种消息驱动的本地事务序列

2.跨服务的操作必须使用所谓的Saga来维护数据一致性，额如是ACID事务，Saga的挑战在于只满足ACD特性，缺乏传统ACID事务的隔离性。

分析协调Saga的两种不同方式：一种时协同是，Saga的产于方在没有集中控制器的情况下交换事件式消息；另一种时编排式，集中控制器告诉Saga参与方要执行的操作做

微服务架构中的事务管理：

分布式事务挑战：

常用方式：2PC：两阶段提交

分布式系统的CAP理论：系统只能在它的一致性、可用性和分区容错性者三个属性中同时保证两个。如今架构倾向于保证系统的可用性，从而放弃数据的强一致性要求。



使用Saga维护数据一致性：

Saga是一种在微服务架构中维护数据一致性的机制，他可以避免分布式事务所带来的问题。

一个Saga表示需要更新多个服务中数据的一个系统操作。Saga由一连串的本地事务组成，每一个本地十五负责更新他所在服务的私有数据库，这些操作依旧以来单体数据库的ACID事务框架和行数库

Saga：通过使用异步消息来协调一系列本地事务，从而维护多个服务之间的数据一致性

Saga使用异步消息机制进行所有参与服务的数据库事务的管理，Saga存在一些挑战：一个是Saga之间缺乏隔离性，另一个是在发生错误时回滚更改问题

Saga使用补偿事务来回滚所作出的改变

在执行到地n个服务的事务时出错，则需要将之前的n-1个事务所作的更改撤销，但是必须手动编写所谓的补偿事务。

Saga的协调模式：

Saga的实现包含协调Saga步骤的逻辑，当通过系统命令启动Saga时，协调按逻辑必须选择并通知第一个Saga参与方执行本地事务，一旦该事务完成，Saga协调选择并调用下一个Saga参与方。这个过程一直持续到Saga执行完所有步骤，如果任何本地事务失败，则Saga必须以相反的顺序执行补偿事务。

构建Saga的协调逻辑的方法：

1.协同式：把Saga的决策和之心顺序逻辑分布在Saga的每一个产于方中，他们通过交换事件的方式来进行沟通

2.编排式：把Saga的决策和执行顺序逻辑集中在一个Saga编排器类中。Saga编排器发出命令式消息给各个Saga产参与方(参与数据变更的服务)，指示这些参与方服务完成具体操作(本地事务)。



协同式Saga:

没有一个中央协调器告诉Saga参与方该做什么，相反，Saga参与方订阅彼此的事件并作出响应的响应

基于协调式的Saga的参与方使用发布/订阅进行交互。

需要做的处理：

1.更新本地数据库和发布时间应该式原子性的，必须使用事务性消息，应该作为本地数据库的一部分，基于协调式的Saga每一步都会更新数据库并发布一个事件

2.确保Saga参与方必须能将接收到的每个事件映射到自己的数据上，解决方案式让Saga产于方发布相关性ID的事件（即在发布的消息中添加相关性ID）

好处:

1.简单：服务在进行命令型操作时发布时间

2.松耦合：参与方订阅事件并且必吃之间不会因此而产生耦合

弊端：

1.更难理解：代码中没有一个单一地方定义了Saga，相反协调是Saga的逻辑分布在每个服务的实现中

2.服务之间的循环以来关系：Saga参与方订阅彼此的事件，这通常会导致循环以来关系

3.紧耦合的防线：每个Saga产于方都需要订阅所有影响他们的事件。



编排式Saga：

当使用编排式Saga式，开发人员定义一个编排器类，这个类的唯一职责就是告诉Saga的产于方该做什么事情，Saga编排器使用命令/异步响应方式与Saga的参与方服务通信。由编排器对某个参与方发出一个命令式的消息，告诉这个参与方该做什么操作。当参与方服务完成操作后，会给编排器发送一个答复消息，并决定Saga的下一步操作是什么。



状态机：

状态机由一组状态和一组由事件触发的状态之间的转换组成。每个转换都可以有一个动作，对Saga来所动作就是对某个参与方的调用。状态之间的转换由Saga参与方执行本地事务的完成触发。当前状态和本地事务的特定结果决定了状态转换以及执行的动作(如果有的话)。

好处：

1.更简单的依赖关系(个人理解不能说更简单，只能说更直观)，不会引入循环依赖关系，Saga编排器调用Saga参与方，但是参与方不会调用编排器，因此编排器依赖于参与方，但是反过来则不成立，因此也不存在循环以来

2.较少的耦合：每个服务实现供编排器调用的API，因此它不需要知道Saga参与方发布的事件

3.改善关注点隔离，简化业务逻辑：Saga的协调逻辑本地化在Saga编排器中，领域对象更加简单，并且不需要了解他们参与的Saga，因此在使用编排式Saga时，服务具有更简单的状态机模型，跟加专注业务

弊端：

在编排器中存在集中过多业务逻辑的风险。这回导致这样的架构设计：智能编排器告诉哑服务要做什么操作。但是可以通过设计只负责排序的编排器来避免此问题，并且不包含任何其他业务逻辑。

建议在架构中使用编排式Saga。为Saga实现协调逻辑只是开发人员需要解决的设计问题之一



缺乏隔离性是使用Saga时面临的最大挑战。

#### 解决隔离问题

Saga只能瞒住ACD三个属性：

1.原子性：Saga实现确保执行所有事物或撤销所有更改。

2.一致性：服务内的参照完整性有本地数据库处理。服务间的参照完整性由服务处理。

3.持久性：由本地数据库处理

缺乏隔离可能导致数据库异常。指多个事务以某种方式(往往是并行)读取或写入数据产生的结果，与多个事务按顺序执行时的记过不同。当异常发生时，并行执行多个Saga的结果与穿行执行的结果不同。

缺乏隔离可能导致的三种异常：

1.丢失更新：一个Saga没有读取更i性能，而是直接覆盖了另一个Saga所做的更改

2.脏读：一个事务或者一个Saga读取了尚未完成的Saga所做的更新

3.模糊或不可重复读：一个Saga的两个不同步骤读取相同的数据却获得了不同的结果，因为另一个Saga已经进行了更新。

Saga模式下实现隔离的对策

1.语义锁：应用程序级的锁

​	使用语义锁对策时，Saga的可补偿性事务会在起创建或更新的任何记录中设置标志。该标志表示该记录未提交且可能发生更改。该标志可以时阻止其他事务访问记录的锁，也可以只是其他事物应该谨慎的处理该记录的一个警告。这个标志会被一个可重复的事务清除以表示Saga成功完成，或通过补偿事务清除。以表示Saga发生回滚。可用实体状态字段来做语义锁。

好处：

他们是指上重新创建了ACID事务提供的隔离。更新相同记录的Saga被序列化，这显著减少了编程工作量；另一个好处是他们消除了客户端重试的负担。

导致脏读的Saga事务：

如用户取消订单中：

1.增加可用额度-->将Order状态更改为取消 -->取消送货

缺点：

应用程序必须管理锁，还需要实现死锁检测算法，该算法执行Saga的回滚以打破死锁并重新执行它。

2.交互式更新：把更新操作设计成可以按任何顺序执行,如果可以按任何顺序执行，那么操作是可交换的

3.悲观视图：重新排序Saga的步骤，以最大限度的降低因为脏读而导致的业务风险：

4.重读值：通过重写数据来防止脏写，以在覆盖数据之前验证它是否保持不变(CAS,先读以变，再读以变，可以防止丢失更新)

5.版本文件：将更新记录下来，以变可以对他们重新排序

6.业务风险评估：使用每个请求的业务风险来动态选择并发机制



Saga的结构：

一个Saga包含三种类型的事务。

1.可补偿性事务：可以使用补偿事务回滚的事务，因此有一个补偿事务

2.关键性事务：Saga执行过程的关键点，如果关键性事务成功，则Saga将一直运行到完成，关键性事务不见得是一个可补偿性事务，或者可重复性事务。但是它可以时最后一个补偿性事务或第一个可重复的事务

3.可重复性事务：在关键性事务之后的事务，保证成功。它不需要回滚并保证能够完成





## 5.业务逻辑设计

##### 1.事务脚本模式

##### 2.领域驱动模式



##### 聚合：	

1.使用时应该只引用聚合跟

2.聚合间的引用必须使用主键

3.一个事务中，只能创建或更新一个聚合



##### 生成和发布领域事件：

理论上讲：领域时间由聚合负责发布，是因为聚合知道其状态何时发生变化，从而知道要发发布的事件。聚合可以直接调用消息传递API，但是弊端在于，聚合不能使用依赖注入，所以消息传递的API需要作为方法的参数传递，这样又将基础设施和业务逻辑交织在一起，这种方式是不可取的。	

更好的方法是聚合和调用它的服务之间分配职责。由服务借助依赖注入来获取对消息传递API的引用从而发布事件(领域事件，及在service层发布事件)





## 6.事件溯源模式模式

将聚合以一系列事件的方式持久化保存。每个事件代表聚合的一次状态变化。应用程序通过重放事件来重新创建聚合的当前状态。(使用一系列表示状态更改的领域事件来持久化聚合)

##### 好处：

1.保留了聚合的历史纪录，这对于实现审计和监管的功能非常有帮助。

2.可靠的发布领域事件

弊端：

1.一定的学习曲线

2.查询时间存储库通常很困难，需要使用CQRS模式



事件溯源把更新聚合的一个方法分解为多个方法：process()方法接受命令并返回事件列表；一个或多个apply()方法，他们接受事件作为输入，并更新聚合



创建聚合的步骤:

1.使用绝的默认构造函数实例化聚合根

2.调用process()以生成新事件

3.遍历新生成的事件并调用apply()来更新聚合的状态

4.经新时间保存在事件存储库中



跟新聚合的步骤：

1.从事件存储库中加载聚合事件

2.使用其默认构造函数实例化聚合跟

3.遍历加载的事件，并在聚合跟上调用apply()方法

4.调用其process()方法以生成新时间

5.遍历新生成的事件并调用apply()来更新聚合状态

6.将新时间保存在事件存储库中





对长生命周期的聚合，可能会有大量的事件，随着时间的推移，加载和重放这些事件会变得越来越低效。

常见的解决方案时顶起持久保存聚合状态的快照，应用程序通过加载最新快照以及仅加载快照后发生的事件来快速回复聚合状态



幂等方式的消息处理：

消息消费者需要确保它是幂等的，因为消息代理可能会多次传递相同的消息

如果可以使用相同的消息多次安全的调用消息接收方，则消息接收方是幂等的。



事件溯源的好处:

1.可靠的发布领域事件

2.保留聚合历史

3.最大限度的避免对象与关系的“阻抗失调”问题

4.为开发者提供一个"时光机"



事件溯源的弊端

编程模式具有一定嘘唏曲线

基于消息传递的应用程序的复杂性(1.需要确保至少一次陈公公传递；2.消费者要实现幂等性)

处理事件的演化有一定难度(好的处理方法，在从事件存储库加载事件时，将事件升级到最新版本)

删除数据存在一定难度

查询事件存储库非常有挑战性(因为存储库中存储的都是事件，不保存状态，因此查询起来不方便，可以借由CQRS解决该问题)

event表：

event_id：

event_type:

entity_type

entity_id

event_data:

version：

triggering_event :(用于检测重复的事件或消息，存储处理生成此事件的消息或事件的ID)



entities表

entity_type:

entity_id:

eneity_version:

...



snapshots表：

entity_type:

entity_id:

entity_version:

snapshot_type:

snapshot_json:

triggering_events:

...



## 7.查询

1.API组合模式

三种实现方式

1.确定架构中那个组建时查询操作的API组合器

a.有服务的客户端扮演API组合器的角色(Controller)

缺点：对防火墙之外的客户以及通过较慢网络访问的服务，此选择不适用

b.由实现应用程序外部API的API Gateway来扮演API组合器的角色

缺点：如果查询操作时应用程序外部API的一部分，则此选择有意义，可以解决防火墙外运行的客户端

c.是将API组合器实现为独立的服务

2.如何编写有效的聚合逻辑



API组合模式的弊端：

1.增加了额外的开销

2.带来可用性降低的风险

3.缺乏事务数据一致性

2.CQRS命令查询职责分离