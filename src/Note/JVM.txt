jvm运行时数据区;
    所有线程共享：
        Method Area(方法区)：是各个线程共享的内存取域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据
        用于存放Class的相关信息，如类名，访问修饰符，常量池，字段描述，方法描述等
            Runtime Constant Pool(运行时常量池)：运行时常量池，方法区的一部分，用于存放编译期生成的字面量和符号引用
        Heap(堆)： 是java虚拟机所管理的内存最大的一块，是被所有线程共享的一块内存区域，在虚拟机启动时创建，唯一目的就是为了存放对象实例，
               几乎所有对象实例都在这里分配内存(new)
                是GC管理的主要取域，现在收集器基本都采用分代收集算法，java中可以细分为新生代和老年代，
    线程私有：
        VM Stack  ---->为虚拟机执行Java方法服务 生命周期与线程相同，是java方法执行的内存模型，每个方法执行时都会创建一个栈帧，用以存储局部变量表，操作数栈，动态链接，方法出口等信息，每一个方法从调用到执行完毕，都对应着一个栈帧在虚拟机栈中从入栈到出栈的过程
                局部变量表：存放编译器可知的各种基本数据类型(boolean,byte,char,short,int,float,long,double),对象引用(reference类型，不等同与对象本身，可能指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址)
                其中64位长度的long和double类型的数据会占用2个局部变量空间(Slot),其余数据类型只占用1个，局部变量表所需的内存空间在编译器间完成分配，当进入一个方法时，这个方法需要在帧中分配对象的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小
        Native Method Stack：为虚拟机执行native方法服务
        Program Counter Register   -->   当前线程所执行的字节码行号指示器



堆: instance （对象实例）或者array这堆中进行内存的分配
方法区：存放Class相关信息(Class定义信息)，

    对象的创建:



对象存活判定算法:
    引用计数算法：给对象添加一个计数器,每当有一个地方引用该对象,计数加一,每当有一个地方不在引用就计数减一，计数为0的对象即为不再被引用，
    但是无法解决循环引用的问题

    可达性分析算法：
    通过一系列的成为“GC Roots”的对象作为起始点，向下搜索，搜索所走过的路径被称为引用链（Reference Chain），当一个对象GC Roots没有任何
    引用链相连时（即GC Roots到该对象不可达），证明该对象为不可用

    java中可以作为GC Roots的有以下几个:
        VM Stack(栈帧中的本地变量表)中引用的对象
        方法区中的静态属性引用的对象
        方法区中常量引用的对象
        本地方法栈中JNI(Native方法)引用的对象

对象的死亡：
    两次标记：
        1.没有与GC Roots相连接的引用链，执行第一次标记并进行一次筛选，筛选条件是否有必要执行finalize()方法，当对象没有覆盖finalize()或者
        已经finalize()已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行
        2.对于经过筛选后虚拟机任务有必要执行的finalize()的方法，那么这个对象会被放置到一个叫做F-Queue的队列中，并稍后由一个虚拟机自动建立的
        、低优先级的Finalizer线程去执行它，这里的执行是指虚拟机会触发它，但是并不会等待它运行结束，这样做的原因是，如果一个对象的finalize()
        执行缓慢，或者发生死循环，将有可能导致F-Queue中的其他对象永远处于等待状态，导致整个内存回收系统崩溃。finalize()是对象摆脱死亡的最后
        一次机会，稍后GC会对F-Queue中的对象进行第二次小规模的标记，如果想不被清除，只需重新与引用链上的任何一个对象建立关联即可，譬如把自己
        赋值给某个类变量或者对象的成员变量，那么在第二次标记时它会被移除即将回收的集合，否则对象将被真正的回收

        ps:
            任何一个对象的finalize()只会被执行一次，也就是说每个对象只有一次自救的机会

引用：
    强引用（StrongReference）Object obj = new Object(); 只要强引用还存在就永远不会被回收
    软引用（SoftReference）还有用但是非必需的对象，对于软引用对象，vm回在发生内存溢出异常前将软引用对象列入回收范围中，进行第二次回收，如果回收后仍没有
              足够的内存，才会抛出内存溢出异常
    弱引用（WeakReference）同样用来描述非必需对象，但是强度比软引用更弱一些，被弱引用引用的对象只能存活到下次垃圾收集之前，当垃圾收集器工作时，
        无论内存是否足够，都会回收掉只被弱引用关联的对象
    虚引用(PhantomReference),也称幽灵引用或者幻影引用，最弱的一种引用关系，完全不会对生存时间构成影响，也无法通过需引用来去的一个实例，
        为一个对象设置需引用的唯一目的就是能够在这个对象被回收的时候收到一个系统通知


方法区(或者永久代)垃圾收集：
    虚拟机规范没有要求一定要对方法区实现垃圾收集，且在方法区进行垃圾收集性价比较低，而在堆中，尤其在新生代中，常规应用进行一次垃圾收集可以回收
    70%~95%的空间，而永久代的垃圾收集效率远低于此

    永久代垃圾收集主要收集“废弃常量”和“无用的类”这两部分内容。
        虚拟机对无用的类的回收时“可以”回收，而不是“必然回收”，是否对类回收可以使用-Xnoclassgc进行控制，还可以使用-verbose:class以及
        -XX:TraceClassLoading和-XX:TraceClassUnLoading查看类加载和类卸载的信息，其中-verbose和traceClassLoading可以在Product版
        虚拟机中使用，TraceClassUnLoading可以在FastDebug版虚拟机中使用

    废弃常量的判定：回收废弃常量和回收堆中的对象非常类似,以常量池中的字面量的回收为例，假如一个字符串“abc”已经进入常量池，但当前系统内没有任何一个String变量叫做“abc”，或者说没有
    任何一个String对象引用常量池中“abc”常量，也没有其它地方引用该字面量，如果此时发生内存回收，而且必要的话，“abc”将会被清出常量池，常量池中
    的其他类（接口）、方法、字段的符号引用也与此类似。
    无用的类的判定：
        1.该类所有的所以实例都已被回收，也就是说heap中不存该类的任何实例；
        2.加载该类的ClassLoader已经被回收；
        3.该类对应的java.lang.Class没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。


垃圾收集算法：
    Mark-Sweep（标记清除）:算法分为“标记”和“清除”两个阶段：首先标记处所有需要回收的对象，标记完成后统一进行回收；
        不足：1.标记和清除两个过程的效率都不高；
             2.清除后会产生大量不连续的内存碎片，内存空间碎片太多可能会导致以后要分配大型对象时，无法找到足够大的连续内存空间而不得不提前触发
             另一次收集动作

    Copying（复制）：将可用内存按照容量划分成两个等大的内存块，每次使用一块，当这一块用完了，就将其中仍然存活的对象复制到另一个内存块中，将原
        来的内存块一次清理掉，这样每次回收都是对半区进行内存回收，分配内存时不用考虑内存碎片等复杂情况，只需要移动堆顶指针，按顺序分配即可，
        实现简单，运行高效。
        不足：1.将原来内存缩小为原来的一半，并且需要分配担保以应对空间不足（100%存活率）；
             2.遇到对象存活率较高的情况时需要进行较多的复制操作，效率降低。

    Mark-Compact（标记整理）:标记过程与“Mark-Sweep”的Mark过程相同，但是后续步骤不是直接对可回收对象进行清理，而是让所有活动对象都移动到一
    端，然后直接清理掉端边界以外的内存（移动活动对象）。

    Generational Collection（分代收集）：根据对象存活周期的不同将内存划分为几块，一把heap划分为新生代和老年代，根据各个年龄代的特点采用合
    适的收集算法，新生代中每次垃圾收集都有大批对象死去，采用Copying算法，老年代中对象存活时间较长，并且没有分配担保，采用标记清除或标记整理算
    法。

    ps:关于老年代和新生代，老年代占据堆的2/3空间，而新生代占据1/3空间（其中新生代又分为Eden，From Survivor，To Survivor，依此占据新
            生代的8/10，1/10，1/10的空间），GC分为两种Minor GC和Full GC(Major GC)，Minor GC是发生在新生代的垃圾收集动作，采用Copying算法
            ，对象每经过一次Minor GC,计数加1，达到15进入老年代；Full GC是老年代发生垃圾收集动作，采用Mark-Sweep算法，Full GC发生次数不会有
            Minor GC那么频繁，并且做一次GC时间要更长。

HotSpot算法实现：
    1.枚举根节点：
        可以作为GC Roots的节点的主要在全局性引用（例如常量和类静态变量）与执行上下文（例如栈帧中的本地变量表）
        GC停顿：在进行可达性分析工作时在一个能确保一致性的快照中进行--这里的一致性是指在整个分析期间整个执行系统看起来像被冻结在某个时间点上，
        不能出现分析过程中对象引用关系还在不断变化的情况，这点导致GC进行时必须停顿所有java执行线程的其中一个愿意，枚举根节点时必须停顿
        ps：准确式GC：虚拟机知道某个位置的数据是什么类型；


    2.SafePoint(安全点)
    3.Safe Region(安全区域)


垃圾收集器：
    并行收集器：指多条收集线程并行工作，但是用户线程仍处于等待状态
    并发收集器：指用户线程和收集线程同时执行(但不一定是并行的，可能会交替执行)，用户线程继续执行，收集线程工作在另一个cpu上
    新生代：
        1.Serial收集器：最基本，发展历史最长久的垃圾收集器，这是一个单线程收集器：只能使用一个CPU或者一条收集线程完成垃圾收集工作，并且必须
            暂停其他所有工作进程，知道它收集结束，适合运行在Client模式下，且是虚拟机运行在Client模式下默认新生代收集器。
        2.ParNew收集器：Serial的多线程版本，但是仍需要等待收集工作完成，是许多运行在server模式下的虚拟机首选的新生代收集器，因为只有Serial
            和ParNew可以和CMS老年代收集器配合工作，也是使用-XX:UseConcMarkSweepGC选项后的默认新生代收集器，也可以通过-XX:+UseParNewGC
            强制指定。
        3.Parallel Scavenge：“吞吐量收集器”，并行多线程收集器，使用Copying算法，与别的专注于减少垃圾收集时用户进程的停顿时间的收集器不同，
            该收集器专注于吞吐量，适合强交互性的应用程序，提供两个参数用于精准控制吞吐量：-XX:MaxGCPauseMillis（设置最大停顿时间），
            -XX：GCTimeRatio(设置垃圾收集时间占比)，-XX:+UseAdaptiveSizePolicy 这是一个开关参数，使用该参数后不需要再设置新生代
            大小和Eden和Survivor的比例、今生老年代对象年龄等参数虚拟机会根据当前系统的运行情况是收集性能监控信息，动态调整这些参数以提供
            最合适的停顿时间或者最大吞吐量，这种调节方式称为GC自适应的调节策略
            ps:
                吞吐量 = 运行用户代码时间/（运行用户代码时间+垃圾收集时间）
                该收集器架构中本身有PS MarkSweep收集器进行老年代收集，并非直接使用Serial Old，但是其与Serial Old的实现十分接近

    老年代：
        1.Serial Old：Serial收集器的老年代版本，使用Mark-Compact算法，意义同样在于Client模式，在Server模式下有两个用途：
            1.与Parallel Scavenge新生代收集器配和使用
            2.作为CMS收集器的后备预案
        2.Parallel Old：Parallel Scavenge的老年代版本，使用多线程和Mark-Compact算法
        3.CMS(Concurrent Mark Sweep)：是一个以获取最小停顿时间的目标的老年代收集器，在尤其重视服务的响应速度，希望系统停顿时间最短的应用
            上尤其适合使用。
            运作过程分为四个阶段：
                初始标记：仅仅标记GC Roots能直接关联的对象，速度很快。
                并发标记：进行GC RootsTracing(GC Roots跟踪)的过程。
                重新标记：对并发标记时引用仍发生变化的引用的修正，这个阶段的停顿比初始标记阶段稍长一些，但远比并发标记短。
                并发清除：
            优点：并发收集，低停顿
            缺点：


关于内存溢出：
    只有程序计数器不会发生oom，剩下的各个地方都会发生oom