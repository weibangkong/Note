MySQL:
    引擎:
        innodb:
            提供事务管理功能，并实现了SQL标准的四个隔离级别，还提供了外键约束和行级锁，设计目标是处理大容量数据库，本身就是基于mysql后台的
            完整数据库系统，MySQL运行时会innodb会在内存中简历缓冲池，用于缓冲和索引，但是该引擎不支持FULLTEXT类型的索引，并且没有保存表的
            行数，当使用count(1)时需要全表扫描，提供事务，锁细粒度小，写操作不会锁全表，所以在并发较高时使用该引擎会提高效率，但是不一定时
            必然不锁全表，在数据库无法判断要扫描的范围时，也会锁全表
        MyISAM:
            MySQL的默认引擎，不支持事务，也不提供行级锁和外键，因此在insert或者update时需要锁全表，效率会第，但是存储了表的行数，count(1)
            时直接读取值而不是扫描，如果表的读操作远多于写操作并且不需要事务的支持，该引擎也不错

        区别：
            1.MyISAM是非事务安全的，innodb是事务安全的
            2.MyISAN锁的细粒度是表级，innodb支持行级锁
            3.MyISAM支持全文类型索引，innodb不支持全文索引
            4.MyISAM效率上比innodb好
            5.MyISAM表保存成文件形式，方便跨平台使用

    mysql -uuserName -ppassword;
    show databases;
    select database(); 查看当前使用的库
    use databaseName;
    create database databaseName default character set utf8;
    drop database databaseName;

    grant PRIVILEGE on databaseName.tableName to userName@"ip" identified by password [with grant option];
        权限:
            all privileges
            create
            select
            insert
            update
            delete
            drop
            alter
            index
            grant
            references
            reload
            shutdown
    with grant option:是该用户可以将自己的权限继承给其他用户

    flush privileges;
    revoke PRIVILEGE ON *.* from userName;

    drop user userName;

    select version();
    select now();

    select user();

    select now();
    select sysdate();
    select current_date;

    delimiter;   分隔符

    drop table if table exists tableName;
    create table tableName (
        id int primary key auto_increment,
        name varchar(32) nuique,
        sex int check(sex in ("0","1")),
        tel varchar(32) not null,
        class int foreign key references t_class(class_id)
    ) endine = innodb default charset = utf8 comment '注释';

视图：
    create view viewName as
        select *****from **** where ****


对表结构进行修改：
    alter table tableName change columeName_a columeName_b columeType;    使用时必须给出原列名和新列名以及列类型
    alter table tableName modify columeName columeType [Constraints];
    alter table tableName add columeName columeType
     [constraints];
    alter table tableName drop columeName;

    约束(Constraints):
        show keys from tableName;   用来查看表上已有约束

        primary key   alter table tableName add primary key(columeName);
                      alter table tableName drop primary key;
        foreign key   alter table tableName1 add foreign key(columeName1) references tableName2(columeName2)
        unique        alter table tableName add unique(columeName);
        not null      alter table tableName add not null(columeName);
        check         alter table tableName add check(columeName condition)  在MySQL中非强制检查，即不满足条件也可插入


        如需对约束命名则在操作后面添加 constraint constraintName，例如：
            alter table tableName add constraint constraintName primary key(columeName);

        如果在知道约束名的情况下，推荐使用如下去除约束的语句：
            alter table tableName index constraintName；


查询：
    select [distinct] columeName from tableName;

    order by columeName DESC(从大到小/降序,ASC为升序/从小到大)

    where name like '%孔维邦%'包含孔维邦
    where name like '孔维邦%' 以孔维邦开头
    where name like '%孔维邦' 以孔维邦结尾


    格式化时间：
    date_fromat(date,'%Y-%m-%d %H:%i:s'); ------------ 2019-03-06 17:28:49

    查看warning:
    show warnings;

delimiter // 定义结速符，当输入定义好的结速符后mysql会立即执行

序列：MySQL中没有列，如果要按照自己的规则实现递增，则需要实现序列，如下实现：
    1.创建序列表
    create table sequence(
        name varchar(50) primary key,
        current_value bigint,
        increment int not null default 1
    ) engine = innodb;
    2.插入序列数据：
    insert into sequence values('seq_1',1,1);
    3.创建返回当前值的函数:
        delimiter// 定义结速符为//
        Drop function if exists currval;
        create function 'currval'(seq_name varchar(50)) returns int
        begin
            declare value int;
            set value = 0;
            select current_value into value from sequence where name = seq_name;
            return value;
        end//
        delimiter ; --更改会原来的默认结束符
    4.创建取下一个值的函数
        delimiter //
        drop function if exists nextval；
        create function nextval(seq_name varchar(50)) returns int
        begin
            update sequence set current_value = current_vale + incrment where name = seq_name;
            return current(seq_name);
        end;//
        delimiter ；
    5.创建更新当前值的函数
        drop function if exists setval;
        create function setval(seq_name varchar(50),newval int) returns int
        begin
            update sequence set cuttent_value = newval where name = seq_name;
            return currval(seq_name);
        end;


    6.为表设置触发器：


function：
    见上面的例子MySQL定义序列的例子
    show function status();

索引：
    create index indexName on tableName(columeName);

触发器：
    delimiter //
    create trigger 'triggerName' BEFORE insert on tableName for each row
    begin
        declare jobno varchar(30);
        declare time1 varchar(20);
        set jobno = (select job_num into jobno from t_job where name = XXX);
        set time1 = date.format(new.date,'%Y-%m-%d %H:%i:s');
        insert into t_job (job_no,time1) values(jobno,time1);
    end;//
    delimiter ;
    触发器使用在改变自身属性时 使用 set new.columeName = 'XXX' 应该用before;
    在触发器中对本表进行操作时，update操作使用set，insert，delete需要借助第二张表
    只有在before insert 触发器中可以更新本表
    例：
        delimiter //
        create trigger tri before insert on tableName for each row begin set new.columeName = XXX;end;//
        delimiter;

    IF...THEN ...[ELSEIF...THEN...]END IF;
存储过程：
    优点：
        1.增强SQL语言的功能和灵活性
        2.标准式的组件编程，一次编码多次使用无需再次编写SQL
        3.较快的执行速度,相对于批处理Transaction-SQL带代码或其被多次执行，存储过程要比批处理快
        4.减少网络流量
        5.可以作为一种安全机制，可以通过对执行某一个存储过程的权限进行控制，实现对相应数据的访问控制，避免非授权用户对数据的访问，保证数据安全

    MySQL5.0开始支持存储过程
    delimiter //
    create procedure proName(in/out/inout 参数 阐述类型...)
        begin
            select count(*) into 参数 from tableName
        end;
    //
    delimiter ;   改行语义：将分割符还原

    参数类型：
        in：必须在调用时指定，在存储过程中修改该类型参数的值不能被返回，是默认值
        out：该值可以在过程中被修改，可以返回
        inout ：调用时指定，并且可以被修改和返回
事务：




用户变量：@

常用函数：
    data_format(data,'%Y-%m-%d %H:%i:%s'); 格式化时间
    ifnull(expr1,expr2) 当expr1为空时返回expr2
    avg(columeName) 取列平均值
    sum(columeName) 取列的和
    count(columeName) 取条目数
    max(columeName) 取列最大值
    min(columeName) 取列最小值
    ucase(columeName) 取列且大写
    lcase(columeName) 取列且小写
    mid(columeName,start[,length])截取列的从start开始的长度为length的字符
    len(columeName)获取列的长度
    round(columeName) 将列精确指定小数位


