并发:
    java.util.concurrent 包下

    线程的四个属性:
        1.优先级: setPriority（）调整，优先级再1-10之间，默认为5，MIN_PRIORITY = 1, MAX_PRIORITY = 10;
                 static void yield(),使调用线程进入让步状态，即将运行权授予相同优先级的其他进程，该方法是一个静态方法。
        2.守护进程 setDemon(boolean isDaemon)设置是否为守护进程。
        3.线程组 ThreadGroup,通过调用getThreadGroup()获取线程所在线程组
        4.未捕获异常处理器 处理器必须实现Thread.UncaughtExceptionHandler接口,
          该接口仅有一个方法void uncaughtExecption(Thread t, Throwable e)

    线程的状态:
        1.new 新创建
        2.runnable 可运行
        3.blocked 被阻塞
        4.waiting 等待
        5.timed waiting 计时等待
        6.terminated 被终止

        ps：如果要查看某个线程的状态，调用getState()即可

    实现多线程的两种方式：
        1. extends(implements)Runnable
        2. extends Thread (实际本质仍然是继承或实现Runnable接口，因为Thread implements)
        3. extends(implements)Callable ,通过FutureTask包装器来创建线程
                例:
                    Callable<Integer> callable = ()->{
                        System.out.println("Callable Interface test");
                        return new Integer(1);
                    };

                    FutureTask oneTask = new FutureTask(callable);
                    Thread thread = new Thread(oneTask);
        4.线程池创建

        ps: Callable是接口是一个参数化的类型，而Runnable是一个非参数化的，可以将Runnable想象成一个没有阐述和返回值的
            异步方法，而Callable是有返回值的

    临界区:
        可能被多个线程同时执行的代码片段

    乐观锁:
        始终认为在自己去拿数据时被人不会修改，所以不会上锁，但是应该提供一种检测机制用以在更新时判断在此期间别人有没有更新数据。
        例如版本号机制，乐观锁适用于多读的应用类型，可以提高吞吐量，像数据库提供的write_condition机制.
        再例如java.util.concurrent.atomic包下的原子变量类(AtomicInteger、AtomicIntegerArray等)

    悲观锁:
        始终任务在自己拿数据时别人会修改，所以在每次拿数据时都会上锁，这样别人在拿数据时必须等待原来锁的持有者释放该锁才可以获得锁
        （例如 java的synchronized关键字，传统型的关系型数据库中的行锁，表锁，读锁，写锁）
        ps：区分数据库中的读锁和java中ReentrantReadWriteLock中的readLock，java中的读锁也可以同时让别人读


    实现同步的的4中方式:
        1.synchronized
        2.ReentrantLock  lock = new ReenTrantLock();
          lock.lock();
          try{
              do something;
          }catch(xxx x){
              do something;
          }finally{
              lock.unlock();
          }
        3.




    阻塞队列(BlockingQueue):
        支持在队列为空时，有线程取元素需等待队列变成非空，在队列满时，有线程存放元素需等待队列变为可用(即非满状态)。
                下面顺序按照添加，返回头元素(不从队列中删除)，移除并返回头元素
        抛出异常型：
            add(e)     IllegalStateExecption
            element()  NoSuchElementExecption
            remove()   NoSuchElementExecption
        返回特殊值型： ----------------推荐使用
            offer(e)   如果队列已满，返回false
            peek()     如果队列为空，返回null
            poll()     如果队列为空，返回null
        阻塞型：
            put(e)      添加阻塞
            take()      移除并返回阻塞

        超时处理：
            offer(e,timeout,timeUnit)
            poll(timeout,timeUnit)

        阻塞队列变种:
            LinkedBlockingQueue:容量没有上边界，也可以指定上边界
            LinkedBlockingDuque:上面队列的双端版本
            ArrayBlockingQueue:构造是需要指定容量，并且具有一个阐述用来指定是否需要公平性，若设置了公平性，则以等待时间最长的线程会优先
                               得到处理。同时使用公平性，会降低性能，只有确有需要时才使用
            PriorityBlockingQueue:带有优先级的队列，而不是先进先出队列，元素按照优先级顺序被移除，该队列没有容量上限，但是队列为空时，
                                  取元素的操作会被阻塞
            DelayQueue:延时队列，该队列实现了Delayed接口，元素只有在延迟用完的情况下才能从DelayQueue移除，还必须实现compareTo方法，
                       DelayQueue使用该方法对元素进行排序，getDelay(timeunit),返回对象的残留延迟(剩余延迟)，负值表示延迟结束。
            TransferQueue:允许生产者线程等待，直到消费者准备就绪，transfer(e):如果有消费者线程正在等待，则直接将该元素交给该消费者线程，
                          否则则将这个线程添加到队列尾部，并阻塞当前线程，直到有消费者线程取走该元素

        场景：
            当使用队列来管理线程时，使用阻塞型，使用put(e),take()
            当向满队列添加元素或者从空队列移除元素，add(e),remove,element会抛出异常
            当在多线程任务中，一定使用offer(e),peek(),poll()

            ps:
                poll()和peek()通过返回null来指示失败，因此向这些队列中插入null是非法的


    并发集合:
        ConcurrentHashMap
            put:放入数据
            putIfAbsent:在key不存在时放入value
            compute:对指定的key的value按照给定方法执行计算
            computeIfAbent:在key不存在时,将指定方法结果赋予value保存，并返回value，如果存在直接返回原来key对应的value
            computeIfPresent:在key已存在的情况下，执行方法，并将结果赋予value，并返回新的value
            merge:当key不存在时，将给定的值赋予value，否则执行指定方法，结合原值和初始值

                PS:compute方法会对键进行处理，merge方法不会对键进行处理
                   如果compute或者merge方法返回null，会从映射中删除现有条目

        ConcurrentSkipListMap
        ConcurrentSkipListSet
        ConcurrentLinkedQueue

    synchronized:
        什么是synchronized：
            synchronized是java关键字,能够将代码块(方法)锁起来，只需在代码块添加synchronized关键字，即可实现同步(阻塞型)
            synchronized是一种互斥锁，一次只允许一个线程进入被锁住的代码块
            synchronized是一种内置锁(监视器锁)，通过汇编发现其是通过
                java中每个对象都有一个内置锁(监视器锁，也可以理解为锁标记)，synchronized就是使用对象的内置锁(监视器)来将代码块(方法)锁定的

        synchronized用处:
            保证了线程的原子性(被保护的代码是一次被执行的，没有任何线程会同时访问)
            保证了可见性(执行完synchronized后，修改后的变量对其他线程是可见的)

        synchronized原理:
            对象内置锁
            monitor监视器


    synchronized与Lock的区别:
        Lock能完成synchronized所实现的所有更能，Lock有比synchronized更精确的线程语义和更好的性能，并且不强制要求一定要获取到锁，
        synchronized会自动释放锁，而Lock必须手动释放，且最好在finally{}中释放

    题目:
        sleep()与wait()的区别:
            1.sleep()使Thread的方法，wait()是Object的方法
            2.sleep()使用户使对象进入停滞(阻塞）状态，但是依旧持有锁，其他线程无法进入临界区代码块等待睡眠时间结束后，时间到达后
            该线程不一定会立即执行，其他线程可能正在执行或者没有被调度为放弃执行
            wait()会使线程进入到一个和该对象相关的等待池中，同时失去对象的机锁(wait(time)超时后还需要返还对象所)，其他线程可以
            访问临界区，wait()后使用notify(),notifyAll()或者指定睡眠时间来唤醒当前等待池中的线程，wait()必须放在synchronized
            block 块中

            最大区别:
                sleep()使线程休眠不释放锁，wait()释放锁
                wait()和sleep()都可以通过interrupt()方法打断线程的暂停状态，使线程抛出InterruptExecption(不推荐)


        sleep()和yield()的区别
            1.sleep()方法给别的线程运行机会时，不会考虑别的进程的优先级，给低优先级的进程运行机会，yield()只给同级或者更高优先级的进程
            运行机会
            2.sleep()使程序阻塞,yield()剥夺线程的运行权，是线程进入就绪态(Runnable)
            3.sleep()抛出InterruptExecption，yield()不会抛出异常
            4.sleep()具有更好的可移植性

        sleep(XX) 休眠
        wait()    等待
        yield()   让步

        线程和进程：
            进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位
            线程是进程的一个实体，是cpu调度和分派的基本单位，是比进程更小的能独立运行的基本单位
            线程的划分尺度小于进程，使得多线程编程通常能带来更好的性能和用户体验，但是多线程程序对其他程序不友好，可能占用更多资源
